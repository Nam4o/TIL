# Day. 08 ( Start )

---

## 목차

- SW 문제 해결
- 복잡도 분석
- 표준 입출력 방법
- 비트 연산
- 진수
- 실수

---

- SW 문제 해결 역량이란 무엇인가를 이해하고 역량을 강화하는 방법을 이해한다.
- 효율적인 알고리즘의 필요성을 이해하고 알고리즘의 성능 측정 방법 중 하나인 시간복잡도에 대해 이해한다.
- 프로그램을 작성하기 위한 기본 중 표준 입출력 방법에 대해 이해한다.
- 비트 수준의 연산과 알고리즘에 대해 이해한다.
- 컴퓨터에서의 실수 표현 방법에 대해 이해한다.

---

## 1. SW 문제 해결

- 프로그래밍하기 위한 제약 조건과 요구사항
    - 프로그래밍 언어의 특성
    - 프로그램이 동작할 HW 와 OS 에 관한 지식
    - 라이브러리들의 유의 사항들
    - 프로그램이 사용할 수 있는 최대 메모리
    - 사용자 대응 시간 제한
    - 재사용성이 높은 간결한 코드

- SW 문제 해결 역량이란
    - 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
    - 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있다.
    - 문제 해결 역량은 추상적인 기술이다.
        - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없다.
        - 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않는다.
    - 문제 해결 역량을 향상시키기 위해서 훈련이 필요하다.

- 문제 해결 과정
    1. 문제를 읽고 이해한다.
    2. 문제를 익숙한 용어로 재정의 한다.
    3. 어떻게 해결할지 계획을 세운다. 
    4. 계획을 검증한다.
    5. 프로그램으로 구현한다.
    6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

- 문제 해결 전략
    - 직관과 체계적인 접근

- 체계적인 접근을 위한 질문들
    - 비슷한 문제를 풀어본 적이 있던가?
    - 단순한 방법에서 시작할 수 있을까?
    - 문제를 단순화 할 수 있을까?
    - 그림으로 그려볼 수 있을까?
    - 수식으로 표현 할 수 있을까?
    - 문제를 분해 할 수 있을까?
    - 뒤에서부터 생각해서 문제를 풀 수 있을까?
    - 특정 형태의 답만을 고려할 수 있을까?
    

---

## 2. 복잡도 분석

### 알고리즘

- 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법. 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다. (간단히, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법)

### 알고리즘의 효율

- 공간적 효율성과 시간적 효율성
    - 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말한다.
    - 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는 가를 말한다.
    - 효율성을 뒤집어 표현하면 복잡도 (Complexity) 가 된다. 복잡도가 높을수록 효율성은 저하된다.
- 시간적 복잡도 분석
    - 하드웨어 환경에 따라 처리시간이 달라진다.
        - 부동소수 처리 프로세서 존재유무, 나눗셈 가속기능 유무
        - 입출력 장비의 성능, 공유여부
    - 소프트웨어 환경에 따라 처리시간이 달라진다.
        - 프로그램 언어의 종류
        - 운영체제, 컴파일러의 종류
    - 이러한 환경적 차이로 인해 분석이 어렵다.
    
- **복잡도의 점근적 표기**
    - 시간 (또는 공간) 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러개의 항을 가지는 다항식이다.
    - 이를 단순한 함수로 표현하기 위해 **점근적 표기** (Asymptotic Notation)를 사용한다.
    - 입력 크기 n 이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.
        - O(Big - Oh) 표기
        - Ω(Big - Omega) 표기
        - Θ(Big - Theta) 표기
        
- O(Big - Oh) 표기
    - O - 표기는 복잡도의 점근적 상한을 나타낸다.
    - 복잡도가 f(n) = 2n^2 - 7n + 4 라면 f(n) 의 O - 표기는 O(n^2) 이다.
    - 먼저 f(n) 의 단순화된 표현은 n^2 이다.
    - 단순화된 함수 n^2 에 임의의 상수 c 를 곱한 cn^2 이 n 이 증가함에 따라 f(n)의 상한이 된다. (단, c > 0)
    
    ⇒ 단순히 **“실행시간이 n^2 에 비례”** 하는 알고리즘이라고 말함.
    
    - n 이 증가함에 따라 O(g(n)) 이 점근적 상한이라는 것 (즉, g(n) 이 n0 보다 큰 모든 n 에 대해서 항상 f(n) 보다 크다는 것) 을 보여준다.
    
   
    

- Ω(Big - Omega) 표기
    - 복잡도의 점근적 하한을 의미한다.
    - f(n) = 2n^2 - 7n + 4 의 Ω - 표기는 Ω(n^2) 이다.
    - f(n) = Ω(n^2) 은 “n 이 증가함에 따라 2n^2 - 7n + 4 가 cn^2 보다 작을 수 없다” 라는 의미이다. 이때 상수 c = 1 로 놓으면 된다.
    - O - 표기 때와 마찬가지로, Ω - 표기도 복잡도 다항식의 최고차항만 계수 없이 취하면 된다.
    - **“최소한 이만한 시간은 걸린다”**
    - 복잡도 f(n) 과 Ω - 표기를 그래프로 나타낸 것인데, n 이 증가함에 따라 Ω(g(n)) 이 점근적 하한이라는 것 (즉, g(n) 이 n0 보다 큰 모든 n 에 대해서 항상 f(n) 보다 작다는 것) 을 보여준다.
    
    
- Θ(Big - Theta) 표기
    - O - 표기와 Ω - 표기가 같은 경우에 사용한다.
    - f(n) = 2n^2 + 8n + 3 = O(n^2) =  Ω(n^2) 이므로, f(n) = Θ(n^2) 이다.
    - “f(n) 은 n 이 증가함에 따라 **n^2 와 동일한 증가율을 가진다**” 라는 의미이다.
    
   

## 3. 표준 입출력 방법

### Python3 표준입출력

- 입력
    - Raw 값의 입력 : input()
        - 받은 입력값을 문자열로 취급
    - Evaluated 된 값 입력 : eval(input())
        - 받은 입력값을 평가된 데이터 형으로 취급

- 출력
    - print()
        - 표준 출력 함수. 출력값의 마지막에 개행 문자 포함
    - print(’text’, end=’’)
        - 출력 시 마지막에 개행문자 제외할 시
    - print(’%d’ % number)
        - Formatting 된 출력

- 파일의 내용을 표준 입력으로 읽어오는 방법
    - import sys
    - sys.stdin = open(”a.txt”, “r”)
    
    ```python
    import sys
    sys.stdin = open("input.txt", "r")
    sys.stout = open("output.txt", "w")
    
    text = input()
    print(text)
    ```
    

---



## 4. 비트 연산

### 비트 연산자

| 연산자 | 연산자의 기능 |
| --- | --- |
| & | 비트 단위로 AND 연산을 한다. |
| | | 비트 단위로 OR 연산을 한다. |
| ^ | 비트 단위로 XOR 연산을 한다. (같으면 0 다르면 1) |
| ~ | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다. |
| << | 피연산자의 비트 열을 왼쪽으로 이동시킨다. |
| >> | 피연산자의 비트 열을 오른쪽으로 이동시킨다. |
- 1 << n
    - 2^n 의 값을 갖는다.
    - 원소가 n 개일 경우의 모든 부분집합의 수를 의미한다.
    - Power set ( 모든 부분 집합 )
        - 공집합과 자기 자신을 포함한 모든 부분 집합
        - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분 집합의 수가 계산된다.

- i & (1 << j)
    - 계산 결과는 i 의 j 번째 비트가 1인지 아닌지를 의미한다.

- 비트 연산 예제 1

```python
def Bbit_print(i):
    output = ' '
    for j in range(7, -1, -1):
        output += '1' if i & (1 << j) else '0'
    print(output)

for i in range(-5, 6)
    print('%3d = ' % i, end='')
    Bbit_print(i)
```

- 비트 연산 예제 2

```python
def Bbit_print(i):
    output = ''
    for j in range(7, -1, -1):
        output += '1' if i & (1 << j) else '0'
    print(output, end='')

a = 0x10
x = 0x01020304
print('%d = ' % a, end='')
Bbit_print(a)
print()
print('0%X= ' % x, end='')
for i in range(0, 4):
    Bbit_print((x >> i * 8) & 0xff)
```

### 엔디안 (Endianness)

→컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍처마다 다르다.

→주의 : 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바로 이해하지 않으면 오류를 발생 시킬 수 있다.

- 빅 엔디안 (Big-endian)
    - 보통 큰 단위가 앞에 나옴. 네트워크.
- 리틀 엔디안 (Little-endian)
    - 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터.



- 엔디안 확인 코드

```python
import sys

print(sys.byteorder)
```

- 비트 연산 예제 3

```python
def ce(n):  # change endian
    p = []
    for i in range(0, 4):
        p.append((x >> (i * 8)) & 0xff)

print('x = %d%d%d%d' % (p[0], p[1], p[2], p[3]))
p = ce(x)
print('x = %d%d%d%d' % (p[0], p[1], p[2], p[3]))
```

- 비트 연산 예제 4

```python
def ce1(n):
    return (n << 24 & 0xff000000) | (n << 8 % 0xff0000)
        | (n >> 8 & 0xff00) | (n >> 24 & 0xff)
```

- 비트 연산 예제 5
    - 비트 연산자 ^를 두 번 연산하면 처음 값을 반환한다.

```python
def Bbit_print(1):
    output = ''
    for j in range(7, -1, -1):
        output += '1' if i & (1 << k) else '0'
    print(output)

a = 0x86
key = 0xAA

print('a    ==> ', end='')
Bbit_print(a)

print('a^=key ==> ', end='')
a ^= key
Bbit_print(a)

print('a^=key ==> ', end='')
a ^= key
Bbit_print(a)
```

---

## 5. 진수

- 2진수, 8진수, 10진수, 16진수

- 10진수 → 타 진수로 변환
    - 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.
    - 예제) (149)10 = (10010101)2 = (225)8 = (95)16