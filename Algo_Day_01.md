# Day.01 ( 배열 1, Array )

---

## 목차

- 알고리즘
- 배열
- 버블 정렬 (Bubble Sort)
- 카운팅 정렬 (Counting Sort)
- 완전 검색
- 그리디 (Greedy Algorithm)

---

## 1. 알고리즘

: 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법.

 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말한다. (어떠한 문제를 해결하기 위한 절차)

- 컴퓨터 분야에서 알고리즘을 표현하는 방법은 두 가지
    - 의사코드 (슈도코드, Pseudocode)와 순서도



- APS 과정의 목표 중의 하나는 보다 좋은 알고리즘을 이해하고 활용하는 것이다.

- 무엇이 좋은 알고리즘인가 ?
    1. **정확성** : 얼마나 정확하게 동작하는가
    2. **작업량** : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
    3. **메모리 사용량** : 얼마나 적은 메모리를 사용하는가
    4. **단순성** : 얼마나 단순한가
    5. **최적성** : 더 이상 개선할 여지없이 최적화되었는가
    
- 주어진 문제를 해결하기 위해 여러 개의 다양한 알고리즘이 가능     ⇒ 어떤 알고리즘을 사용해야 하는가?

- 알고리즘의 성능 분석 필요
    - 많은 문제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교한다
    
    
    

- 알고리즘의 작업량을 표현할 때 시간복잡도로 표현한다
    
    
- 시간 복잡도 (Time Complexity)
    - 실제 걸리는 시간을 측정
    - 실행되는 명령문의 개수를 계산
    


### ✔**시간 복잡도 - 빅 - 오(O) 표기법**

- 빅-오 표기법

- 시간 복잡도가 최악일 때, 상한선을 표기
    
    : **점근적인 상한선을 표기하기 위해 사용**
    
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시

- 계수는 생략하여 표시

예)

- n개의 데이터를 입력 받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 화면에 출력하는 알고리즘의 시간 복잡도는 어떻게 되는가
    
    → O(n)
    

- 요소  수가 증가함에 따라 각기 다른 시간복잡도의 알고리즘은 아래와 같은 연산 수를 보인다.



- 시간 복잡도별 실제 실행 시간 비교



---

## 2. 배열

: 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

- 아래의 예는 6개의 변수를 사용해야 하는 경우, 이를 배열로 바꾸어 사용하는 것이다.

```python
Num0 = 0
Num1 = 1
Num2 = 2
Num3 = 3
Num4 = 4
Num5 = 5

# 배열로 바꾸어 사용
Num = [0, 1, 2, 3, 4, 5]
```

- 배열의 필요성
    - 프로그램 내에서 여러 개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있다.
    - 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.
    - 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

- 1차원 배열의 선언
    - 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
    - 이름 : 프로그램에서 사용할 배열의 이름
        
        Arr = list() , Arr = []  (1차원 배열 선언의 예)
        
        Arr= [1, 2, 3]  , Arr = [0] * 10
        

- 1차원 배열의 접근
    - Arr[0] = 10  # 배열 Arr의 0번 원소에 10을 저장하라
    - Arr[idx] = 20  # 배열 Arr의 idx번 원소에 20을 저장하라
    

---

## 3. 정렬

: 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값( 오름차순 ) 혹은 그 반대의 순서대로 ( 내림차순) 재배열하는 것

| 알고리즘 | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고 |
| --- | --- | --- | --- | --- |
| 버블 정렬 | O(n^2) | O(n^2) | 비교와 교환 | 코딩이 가장 손쉽다 |
| 카운팅 정렬 | O(n + k) | O(n + k) | 비교환 방식 | n이 비교적 작을 때만 가능 |
| 선택 정렬 | O(n^2) | O(n^2) | 비교와 교환 | 교환의 회수가 버블, 삽입정렬보다 작다 |
| 퀵 정렬 | O(n log n) | O(n^2) | 분할 정복 | 최악의 경우 O(n^2)이지만,평균적으로는 가장 빠르다 |
| 삽입 정렬 | O(n^2) | O(n^2) | 비교와 교환 | n의 개수가 작을 때 효과적이다 |
| 병합 정렬 | O(n log n) | O(n log n) | 분할 정복 | 연결리스트의 경우 가장 효율적인 방식 |

- 키
    - 자료를 정렬하는 기준이 되는 특정 값
    
    ex) 서류를 번호대로 정렬하기 / 카드를 번호대로 정렬하기
    
- ✔**대표적인 정렬 방식의 종류**
    - 버블 정렬 (Bubble Sort)
    - 카운팅 정렬 (Counting Sort)
    - 선택 정렬 (Selection Sort)
    - 퀵 정렬 (Quick Sort)
    - 삽입 정렬 (Insert Sort)
    - 병합 정렬 (Merge Sort)
    
- APS 과정을 통해 자료구조와 알고리즘을 학습하면서 다양한 형태의 정렬을 학습하게 된다.

### 1. 버블 정렬

: **인접한 두 개의 원소를 비교**하여 자리를 계속 교환하는 방식

- 정렬 과정
    - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
    - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
    - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.

- 시간 복잡도 O(n^2)

- 배열을 활용한 버블 정렬
    - 앞서 살펴 본 정렬 과정을 코드로 구현하면 아래와 같다 (오름차순)
    
    ```python
    BubbleSort(a, N)               # 정렬할 배열과 배열의 크기
        for i : N-1 -> 1         # 정렬 될 구간의 끝
            for j : 0 -> i-1     # 비교할 원소 중 왼쪽 원소의 인덱스
    						if a[j] > a[j + 1]     # 왼쪽 원소가 더 크면
    								a[j] <-> a[j + 1]  # 오른쪽 원소와 교환
    ```
    
    ```python
    def BubbleSort(a, N):  # 정렬할 List, N 원소 수
    		for i in range(N-1, 0, -1):  # 범위의 끝 위치
    				for j in range(0, i):
    						if a[j] > a[j + 1]:
                    a[j], a[j + 1] = a[j + 1], a[j]
    ```
    

---

### 2. 카운팅 정렬

: 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 효율적인 알고리즘

- 제한 사항
    - **정수나 정수로 표현할 수 있는 자료에 대해서만 적용가능**
    
    → 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
    
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.

- 시간 복잡도
    - O(n + k) : n 은 리스트 길이, k 는 정수의 최대값

- 

```python
# result = input()  # "1 2 3 4 5 6 7"
# 리스트화 .. 문자열 메소드 split
# result = reuslt.split(' ')  # ['1', '2', '3', '4', '5', '6', '7']

# map함수 -> 객체 map -> 리스트 형변환
# list(map(int, result))  # [1, 2, 3, 4, 5, 6, 7]

list(map(int, input().split(' ')))  # '1 2 3 4 5 6 7' -> [1, 2, 3, 4, 5, 6, 7]

# '1234567' -> [1, 2, 3, 4, 5, 6, 7]
list(map(int, input()))

print(result)

```

- 카운팅 정렬 알고리즘

```python
def Counting_Sort(A, B, k)
# A [] -- 입력 배열 (0 to k)
# B [] -- 정렬된 배열
# C [] -- 카운트 배열

C = [0] * (k + 1)

for i in range(0, len(A)):
    C[A[i]] += 1

for i in range(1, len(C)):
    C[i] += C[i - 1]

for i in range(len(B) - 1, -1, -1):
    C[A[i]] -= 1
    B[C[A[i]]] = A[i]
```

---

### 3. 완전 검색

- Baby-gin Game
    1. 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run 이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet 이라고 한다.
    2. 그리고, 6장의 카드가 run 과 triplet 로만 구성된 경우를 baby-gin 으로 부른다.
    3. 6자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라.
    - 입력 예
        - 667767 은 두 개의 triplet 이므로 baby-gin 이다. (666, 777)
        - 054060 은 한 개의 run 과 한 개의 triplet 이므로 역시 baby-gin 이다. (456, 000)
        - 101123 은 한 개의 triplet 가 존재하나, 023 이 run 이 아니므로 baby-gin 이 아니다.
            
            (123 을 run 으로 사용하더라도 011 이 run 이나 triplet 가 아님)
            
    - 6자리의 숫자를 입력 받아 어떻게 baby-gin 여부를 찾을 것인가?

- 완전 검색
    - 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.
    - Brute-force 혹은 generate-and-test 기법이라고도 불리운다.
    - 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
    - 일반덕으로 경우의 수가 상대적으로 작을 때 유용하다.

- 완전 검색으로 시작하라
    - 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
    - 자격검정평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.
    
- 완전 검색을 활용한 Baby-gin 접근
    - 고려할 수 있는 모든 경우의 수 생성하기
        - 6개의 숫자로 만들 수 있는 모든 숫자 나열 (중복 포함)
        - 예) 입력으로 [2, 3, 5, 7, 7, 7] 을 받았을 경우, 아래와 같이 순열을 생성할 수 있다.
        
        [2 3 5 7 7 7], [2 3 7 5 7 7], [2 3 7 7 5 7] . . . [7 7 7 5 3 2] <모든 경우의 순열 나열>
        
    - 해답 테스트하기
        - 앞의 3자리와 뒤의 3자리를 잘라, run 과 triplet 여부를 테스트하고 최종적으로 baby-gin 을 판단한다.
        - 예) [2, 3, 5, 7, 7, 7]  ← [2, 3, 5] (해당 없음) [7, 7, 7] (triplet) ← baby-gin 아님
    - 순열
        - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
        - 서로 다른 n개 중 r개를 택하는 순열은 nPr 로 표현한다.
        - nPr 은 다음과 같은 식이 성립한다.
            
            nPr = n * (n - 1) * (n - 2) * … * (n - r + 1)
            
        - nPn = n! 이라고 표기하며 Factorial 이라 부른다.
            
            n! = n * (n - 1) * (n - 2) * … * 2 * 1
            
    - 예) {1, 2, 3} 을 포함하는 모든 순열을 생성하는 함수
        - 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop을 이용해 아래와 같이 구현할 수 있다.
        
        ```python
        for i1 in range(1, 4):
        		for i2 in range(1, 4):
        				if i2 != i1:
        						for i3 in range(1, 4):
        								if i3 != i1 and i3 != i2:
        										print(i1, i2, i3)
        ```
        
        → 재귀함수 → 완전 탐색
        

---

### 4. 탐욕 (Greedy) 알고리즘

: 탐욕 알고리즘은 **최적해를 구하는 데 사용되는(매 순간 최적의 방법)** 근시안적인 방법

"**탐욕 (Greedy) 문제인지 의심 될 경우, 먼저 완전 탐색 or DP 와 같은 방식으로 먼저 접근하는 방법이 더 안전한 방법일 수 있다. “**

- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택의 시점에서 이루어지는 결정은 **지역적으로는 최적(*Local goal)**이지만, 그 선택들을 계속 수집하여 **최종적인 해답(*Global goal)**을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
    
    *Local goal : 매 순간 최적의 선택 / *Global goal : 최종적으로 최적의 선택 (Local goal 중 가장 최적) 
    
- 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.

- 탐욕 알고리즘의 동작 과정
    1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Soultion Set)에 추가한다.
    2. 실행 가능성 검사 : 새로운 부분에 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
    3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1. 의 해 선택부터 다시 시작한다.
- 거스름돈 줄이기
    - “어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?”

- Baby-gin 을 완전 검색이 아닌 방법으로 풀어보자.
    - 6개의 숫자는 6자리의 정수 값으로 입력된다.
    - counts 배열의 각 원소를 체크하여 run 과 triplet 및 baby-gin 여부를 판단한다.
    - 풀이
        
        ex) 444345
        
                    1   2   3   4   5   6   7   8   9   0
        
        counts             1    4   1                          ← run 조사 후 run 데이터 완전 삭제
        
                    1   2   3   4   5   6   7   8   9   0
        
        counts                   3                               ⇒ Baby-gin
        
        ex) 444456
        
                    1   2   3   4   5   6   7   8   9   0
        
        counts                  4   1   1                      ← triplet 조사 후 triplet 데이터 완전 삭제
        
                    1   2   3   4   5   6   7   8   9   0
        
        counts                  1   1   1                      ⇒ Baby-gin
        
        **구현 예)**
        
        ```python
        num = 456789  # Baby-gin 확인할 6자리 수
        c = [0] * 12  # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트
        # i 의 range 가 0 ~ 9 일때 , i + 2 까지 순회하므로 리스트의 크기를 12 까지 늘리면,
        # 불필요한 연산 (i < 8) 을 뺄 수 있는 만큼 성능이 개선
        
        for i in range(6):
        		c[num % 10] += 1
        		num //= 10
        ```
        
        ```python
        i = 0
        tri = run = 0
        while i < 10:
        		if c[i] >= 3:  # triplet 조사 후 데이터 삭제
        				c[i] -= 3
        				tri += 1
        				continue
        		if c[i] >= 1 and c[i + 1] >= 1 and c[i + 2] >= 1:  # run 조사 후 데이터 삭제
        				c[i] -= 1
        				c[i + 1] -= 1
        				c[i + 2] -= 1
        				run += 1
        				continue
        		i += 1
        
        if run + tri == 2:
        		print('Baby-gin')
        else:
        		print('Lose')
        ```
        
    
    - 자주 실수하는 오답
        - 입력받은 숫자를 정렬한 후, 앞뒤 3자리씩 끊어서 run 및 triplet을 확인하는 방법을 고려할 수도 있다.
            - 예) [6, 4, 4, 5, 4, 4]
                - 정렬하여 [4, 4, 4, 4, 5, 6] 을 얻어내면 쉽게 baby-gin 을 확인할 수 있다.
            - 예) [1, 2, 3, 1, 2, 3]
                - 정렬하면 [1, 1, 2, 2, 3, 3] 로서, 오히려 baby-gin 확인을 실패할 수 있다.
        - 위의 예처럼, 탐욕 알고리즘적인 접근은 해답을 찾아내지 못하는 경우도 있으니 유의해야 한다.